from enum import Enum
from pathlib import Path
from typing import Type, Union

import lightning as L
import numpy as np
import torch
from laplace import HessianStructure, Laplace, Likelihood, SubsetOfWeights
from lightning_uq_box.uq_methods import DeterministicModel, LaplaceRegression
from nngeometry.object import PMatDense, PMatDiag, PMatKFAC, PMatLowRank
from scipy.stats import gaussian_kde

from src.ssl import (
    ASSLAApproximationStrategy,
    SelfSupervisedLaplace,
    SSLAApproximationStrategy,
)
from src.ssl.SamplingStrategy import NeighborhoodSampling

## Helper ##


class CI(float, Enum):
    NINTY_FIVE = 1.96
    NINTY = 1.64
    SEVENTY_FIVE = 1.15
    FIFTY = 0.67


def coverage(pred, dm, ci: CI = CI.NINTY_FIVE):
    def _coverage(lower: torch.Tensor, upper: torch.Tensor, y_test):
        within_interval = ((y_test >= lower) & (y_test <= upper)).float()
        coverage_rate = within_interval.mean().item() * 100
        return coverage_rate

    y_test = dm.Y_test.flatten()

    lower, upper = (
        pred["pred"].flatten() - ci * pred["pred_uct"].flatten(),
        pred["pred"].flatten() + ci * pred["pred_uct"].flatten(),
    )
    return _coverage(lower, upper, y_test)


def compute_kde_from_ssla(dists: list[dict]):
    for dist in dists:
        data = list(map(lambda x: x["y"].item(), dist["dist"]))
        weights = list(map(lambda x: x["log_ppd"].exp().item(), dist["dist"]))
        weights = torch.tensor(weights)
        weights /= weights.sum()
        kde = gaussian_kde(dataset=data, weights=weights.numpy())
        dist.update({"kde": kde})
    return dists


def ssla_dists_to_l_uq_box(dists: list[dict]):
    pred_values = [dist["y"].item() for dist in dists]
    pred_uct_values = [np.sqrt(dist["kde"].covariance) for dist in dists]
    return {
        "pred": torch.tensor(pred_values),
        "pred_uct": torch.tensor(pred_uct_values),
    }


def generate_readme(title, dgp, prior, experiment_path: Path):
    text = f"""Autogenerated README.
    
    Experiment Title: {title}
    ----
    Data-Generating Process:
    {dgp}
    ----
    Prior:
    {prior}
    """

    with open(experiment_path / "README.md", "w") as f:
        f.write(text)


## UQ METHODS ##


def la(
    model,
    dm: L.LightningDataModule,
    temp_file,
    likelihood: Likelihood = Likelihood.REGRESSION,
    subset_of_weights: SubsetOfWeights = SubsetOfWeights.LAST_LAYER,
    hessian_structure: HessianStructure = HessianStructure.KRON,
):
    la = Laplace(
        model=model,
        likelihood=likelihood,
        subset_of_weights=subset_of_weights,
        hessian_structure=hessian_structure,
    )
    laplace_model = LaplaceRegression(laplace_model=la, tune_prior_precision=True)
    trainer = L.Trainer(default_root_dir=temp_file, deterministic=True)
    trainer.test(laplace_model, datamodule=dm)
    la_preds = laplace_model.predict_step(dm.X_test)
    return la_preds


def assla(
    model: DeterministicModel,
    dm,
    fim_represetation: Union[
        Type[PMatKFAC], Type[PMatDense], Type[PMatLowRank], Type[PMatDiag]
    ] = PMatKFAC,
):
    preds = model.predict_step(dm.X_test)
    ssla = SelfSupervisedLaplace(
        model=model, n_outputs=dm.Y_train.shape[1], fim_represetation=fim_represetation
    )
    dists = ssla.sample_log_ppd(
        dm.X_test,
        preds["pred"],
        dm.X_train,
        dm.Y_train,
        approximation_strategy=ASSLAApproximationStrategy(),
        sampling_strategy=NeighborhoodSampling(n=30),
    )
    return dists


def ssla(
    model: DeterministicModel,
    dm,
    fim_represetation: Union[
        Type[PMatKFAC], Type[PMatDense], Type[PMatLowRank], Type[PMatDiag]
    ] = PMatKFAC,
):
    preds = model.predict_step(dm.X_test)
    ssla = SelfSupervisedLaplace(
        model=model, n_outputs=dm.Y_train.shape[1], fim_represetation=fim_represetation
    )
    weights = torch.cat([w.view(-1) for w in model.parameters()])
    prior_fn = torch.distributions.MultivariateNormal(
        loc=torch.zeros_like(weights), covariance_matrix=torch.eye(n=weights.shape[0])
    )
    dists = ssla.sample_log_ppd(
        dm.X_test,
        preds["pred"],
        dm.X_train,
        dm.Y_train,
        approximation_strategy=SSLAApproximationStrategy(prior=prior_fn),
        sampling_strategy=NeighborhoodSampling(n=20),
    )
    return dists
